
ARM-UART.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007c8  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000434  20000000  000007c8  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000250  20000434  00000bfc  00020434  2**2
                  ALLOC
  3 .stack        00002004  20000684  00000e4c  00020434  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020434  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002045c  2**0
                  CONTENTS, READONLY
  6 .debug_info   000085f3  00000000  00000000  000204b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000872  00000000  00000000  00028aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00000472  00000000  00000000  0002931a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000108  00000000  00000000  0002978c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000000b8  00000000  00000000  00029894  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00011df0  00000000  00000000  0002994c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000023c2  00000000  00000000  0003b73c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0007194c  00000000  00000000  0003dafe  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000003c4  00000000  00000000  000af44c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
   0:	88 26 00 20 2d 02 00 00 29 02 00 00 29 02 00 00     .&. -...)...)...
	...
  2c:	29 02 00 00 00 00 00 00 00 00 00 00 29 02 00 00     )...........)...
  3c:	1d 02 00 00 29 02 00 00 29 02 00 00 29 02 00 00     ....)...)...)...
  4c:	29 02 00 00 29 02 00 00 29 02 00 00 29 02 00 00     )...)...)...)...
  5c:	29 02 00 00 29 02 00 00 29 02 00 00 29 02 00 00     )...)...)...)...
  6c:	29 02 00 00 a1 03 00 00 29 02 00 00 29 02 00 00     ).......)...)...
  7c:	29 02 00 00 29 02 00 00 29 02 00 00 29 02 00 00     )...)...)...)...
  8c:	29 02 00 00 29 02 00 00 29 02 00 00 29 02 00 00     )...)...)...)...
  9c:	29 02 00 00 29 02 00 00 29 02 00 00 29 02 00 00     )...)...)...)...
  ac:	29 02 00 00 00 00 00 00                             ).......

000000b4 <__do_global_dtors_aux>:
  b4:	b510      	push	{r4, lr}
  b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
  b8:	7823      	ldrb	r3, [r4, #0]
  ba:	2b00      	cmp	r3, #0
  bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
  be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
  c0:	2b00      	cmp	r3, #0
  c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
  c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
  c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
  c8:	bf00      	nop
  ca:	2301      	movs	r3, #1
  cc:	7023      	strb	r3, [r4, #0]
  ce:	bd10      	pop	{r4, pc}
  d0:	20000434 	.word	0x20000434
  d4:	00000000 	.word	0x00000000
  d8:	000007c8 	.word	0x000007c8

000000dc <frame_dummy>:
  dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
  de:	b510      	push	{r4, lr}
  e0:	2b00      	cmp	r3, #0
  e2:	d003      	beq.n	ec <frame_dummy+0x10>
  e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
  e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
  e8:	e000      	b.n	ec <frame_dummy+0x10>
  ea:	bf00      	nop
  ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
  ee:	6803      	ldr	r3, [r0, #0]
  f0:	2b00      	cmp	r3, #0
  f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
  f4:	bd10      	pop	{r4, pc}
  f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
  f8:	2b00      	cmp	r3, #0
  fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
  fc:	4798      	blx	r3
  fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
 100:	00000000 	.word	0x00000000
 104:	20000438 	.word	0x20000438
 108:	000007c8 	.word	0x000007c8
 10c:	000007c8 	.word	0x000007c8
 110:	00000000 	.word	0x00000000

00000114 <init_32KXTAL>:
#include "sam.h"
#include "SetClk.h"

void init_32KXTAL()
{
	SYSCTRL->XOSC32K.reg = SYSCTRL_XOSC32K_ENABLE;	//Odblokuj zegar 32768Hz - kwarc
 114:	4b05      	ldr	r3, [pc, #20]	; (12c <init_32KXTAL+0x18>)
 116:	2202      	movs	r2, #2
 118:	829a      	strh	r2, [r3, #20]
	SYSCTRL->XOSC32K.reg|= SYSCTRL_XOSC32K_STARTUP(5) | SYSCTRL_XOSC32K_AAMPEN | SYSCTRL_XOSC32K_EN32K | SYSCTRL_XOSC32K_XTALEN | SYSCTRL_XOSC32K_ENABLE ;
 11a:	8a9a      	ldrh	r2, [r3, #20]
 11c:	4904      	ldr	r1, [pc, #16]	; (130 <init_32KXTAL+0x1c>)
 11e:	430a      	orrs	r2, r1
 120:	829a      	strh	r2, [r3, #20]
	
	while((REG_SYSCTRL_PCLKSR & (SYSCTRL_PCLKSR_XOSC32KRDY)) == 0); // zaczekaj a¿ zegar bêdzie gotowy
 122:	4b04      	ldr	r3, [pc, #16]	; (134 <init_32KXTAL+0x20>)
 124:	681b      	ldr	r3, [r3, #0]
 126:	079b      	lsls	r3, r3, #30
 128:	d5fb      	bpl.n	122 <init_32KXTAL+0xe>
}
 12a:	4770      	bx	lr
 12c:	40000800 	.word	0x40000800
 130:	0000052e 	.word	0x0000052e
 134:	4000080c 	.word	0x4000080c

00000138 <init_generic_clocks>:

void init_generic_clocks()
{
	GCLK->GENDIV.reg = GCLK_GENDIV_DIV(1) | GCLK_GENDIV_ID(1);  //Brak podzia³u CLK
 138:	4b04      	ldr	r3, [pc, #16]	; (14c <init_generic_clocks+0x14>)
 13a:	2202      	movs	r2, #2
 13c:	32ff      	adds	r2, #255	; 0xff
 13e:	609a      	str	r2, [r3, #8]
	GCLK->GENCTRL.reg = GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_XOSC32K | GCLK_GENCTRL_ID(1);  //Generator 1 taktowany z zegara 32768 Hz
 140:	4a03      	ldr	r2, [pc, #12]	; (150 <init_generic_clocks+0x18>)
 142:	605a      	str	r2, [r3, #4]
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(1) | GCLK_CLKCTRL_ID_DFLL48;  //Uruchom DFLL 48 MHz
 144:	2282      	movs	r2, #130	; 0x82
 146:	01d2      	lsls	r2, r2, #7
 148:	805a      	strh	r2, [r3, #2]
}
 14a:	4770      	bx	lr
 14c:	40000c00 	.word	0x40000c00
 150:	00010501 	.word	0x00010501

00000154 <init_FDLL48>:

void init_FDLL48()
{
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE ;  //Uruchom DFLL
 154:	4a09      	ldr	r2, [pc, #36]	; (17c <init_FDLL48+0x28>)
 156:	2302      	movs	r3, #2
 158:	8493      	strh	r3, [r2, #36]	; 0x24
	SYSCTRL->DFLLMUL.reg = (SYSCTRL_DFLLMUL_FSTEP(10)) | (SYSCTRL_DFLLMUL_CSTEP(5)) | (SYSCTRL_DFLLMUL_MUL(1465));
 15a:	4b09      	ldr	r3, [pc, #36]	; (180 <init_FDLL48+0x2c>)
 15c:	62d3      	str	r3, [r2, #44]	; 0x2c
	SYSCTRL->DFLLCTRL.reg |=  SYSCTRL_DFLLCTRL_MODE;
 15e:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 160:	2104      	movs	r1, #4
 162:	430b      	orrs	r3, r1
 164:	b29b      	uxth	r3, r3
 166:	8493      	strh	r3, [r2, #36]	; 0x24
	
	while((REG_SYSCTRL_PCLKSR & (SYSCTRL_PCLKSR_DFLLLCKC)) == 0);  //Poczekaj na stabilizacjê pêtli
 168:	4b06      	ldr	r3, [pc, #24]	; (184 <init_FDLL48+0x30>)
 16a:	681b      	ldr	r3, [r3, #0]
 16c:	061b      	lsls	r3, r3, #24
 16e:	d5fb      	bpl.n	168 <init_FDLL48+0x14>
	
	NVMCTRL->CTRLB.reg |= (NVMCTRL_CTRLB_RWS(1));  //Liczba WSów do FLASH
 170:	4a05      	ldr	r2, [pc, #20]	; (188 <init_FDLL48+0x34>)
 172:	6853      	ldr	r3, [r2, #4]
 174:	2102      	movs	r1, #2
 176:	430b      	orrs	r3, r1
 178:	6053      	str	r3, [r2, #4]
}
 17a:	4770      	bx	lr
 17c:	40000800 	.word	0x40000800
 180:	140a05b9 	.word	0x140a05b9
 184:	4000080c 	.word	0x4000080c
 188:	41004000 	.word	0x41004000

0000018c <init_generick_clock0>:

void init_generick_clock0()
{
	GCLK->GENDIV.reg = GCLK_GENDIV_DIV(1) | GCLK_GENDIV_ID(0);
 18c:	4b04      	ldr	r3, [pc, #16]	; (1a0 <init_generick_clock0+0x14>)
 18e:	2280      	movs	r2, #128	; 0x80
 190:	0052      	lsls	r2, r2, #1
 192:	609a      	str	r2, [r3, #8]
	GCLK->GENCTRL.reg = GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_DFLL48M | GCLK_GENCTRL_ID(0);
 194:	4a03      	ldr	r2, [pc, #12]	; (1a4 <init_generick_clock0+0x18>)
 196:	605a      	str	r2, [r3, #4]
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_GEN(0) | GCLK_CLKCTRL_CLKEN;
 198:	2280      	movs	r2, #128	; 0x80
 19a:	01d2      	lsls	r2, r2, #7
 19c:	805a      	strh	r2, [r3, #2]
}
 19e:	4770      	bx	lr
 1a0:	40000c00 	.word	0x40000c00
 1a4:	00010700 	.word	0x00010700

000001a8 <Set48MHzClk>:

void Set48MHzClk()
{
 1a8:	b510      	push	{r4, lr}
	init_32KXTAL();
 1aa:	4b0d      	ldr	r3, [pc, #52]	; (1e0 <Set48MHzClk+0x38>)
 1ac:	4798      	blx	r3
	init_generic_clocks();
 1ae:	4b0d      	ldr	r3, [pc, #52]	; (1e4 <Set48MHzClk+0x3c>)
 1b0:	4798      	blx	r3
	init_FDLL48();
 1b2:	4b0d      	ldr	r3, [pc, #52]	; (1e8 <Set48MHzClk+0x40>)
 1b4:	4798      	blx	r3
	init_generick_clock0();
 1b6:	4b0d      	ldr	r3, [pc, #52]	; (1ec <Set48MHzClk+0x44>)
 1b8:	4798      	blx	r3
	SystemCoreClock=48000000UL;  //Bie¿¹ce taktowanie MCU
 1ba:	4a0d      	ldr	r2, [pc, #52]	; (1f0 <Set48MHzClk+0x48>)
 1bc:	4b0d      	ldr	r3, [pc, #52]	; (1f4 <Set48MHzClk+0x4c>)
 1be:	601a      	str	r2, [r3, #0]
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 1c0:	4a0d      	ldr	r2, [pc, #52]	; (1f8 <Set48MHzClk+0x50>)
 1c2:	4b0e      	ldr	r3, [pc, #56]	; (1fc <Set48MHzClk+0x54>)
 1c4:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
 1c6:	480e      	ldr	r0, [pc, #56]	; (200 <Set48MHzClk+0x58>)
 1c8:	6a03      	ldr	r3, [r0, #32]
 1ca:	021b      	lsls	r3, r3, #8
 1cc:	0a1b      	lsrs	r3, r3, #8
 1ce:	21c0      	movs	r1, #192	; 0xc0
 1d0:	0609      	lsls	r1, r1, #24
 1d2:	430b      	orrs	r3, r1
 1d4:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 1d6:	2300      	movs	r3, #0
 1d8:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 1da:	3307      	adds	r3, #7
 1dc:	6013      	str	r3, [r2, #0]
	SysTick_Config(SystemCoreClock / 1000);
 1de:	bd10      	pop	{r4, pc}
 1e0:	00000115 	.word	0x00000115
 1e4:	00000139 	.word	0x00000139
 1e8:	00000155 	.word	0x00000155
 1ec:	0000018d 	.word	0x0000018d
 1f0:	02dc6c00 	.word	0x02dc6c00
 1f4:	20000000 	.word	0x20000000
 1f8:	e000e010 	.word	0xe000e010
 1fc:	0000bb7f 	.word	0x0000bb7f
 200:	e000ed00 	.word	0xe000ed00

00000204 <TimingDelay_Decrement>:

__IO uint32_t TimingDelay;

void TimingDelay_Decrement(void)
{
	if (TimingDelay != 0x00) TimingDelay--;
 204:	4b04      	ldr	r3, [pc, #16]	; (218 <TimingDelay_Decrement+0x14>)
 206:	681b      	ldr	r3, [r3, #0]
 208:	2b00      	cmp	r3, #0
 20a:	d003      	beq.n	214 <TimingDelay_Decrement+0x10>
 20c:	4a02      	ldr	r2, [pc, #8]	; (218 <TimingDelay_Decrement+0x14>)
 20e:	6813      	ldr	r3, [r2, #0]
 210:	3b01      	subs	r3, #1
 212:	6013      	str	r3, [r2, #0]
}
 214:	4770      	bx	lr
 216:	46c0      	nop			; (mov r8, r8)
 218:	20000450 	.word	0x20000450

0000021c <SysTick_Handler>:

void SysTick_Handler(void)
{
 21c:	b510      	push	{r4, lr}
	TimingDelay_Decrement();
 21e:	4b01      	ldr	r3, [pc, #4]	; (224 <SysTick_Handler+0x8>)
 220:	4798      	blx	r3
 222:	bd10      	pop	{r4, pc}
 224:	00000205 	.word	0x00000205

00000228 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 228:	e7fe      	b.n	228 <Dummy_Handler>
	...

0000022c <Reset_Handler>:
{
 22c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
 22e:	4a23      	ldr	r2, [pc, #140]	; (2bc <Reset_Handler+0x90>)
 230:	4b23      	ldr	r3, [pc, #140]	; (2c0 <Reset_Handler+0x94>)
 232:	429a      	cmp	r2, r3
 234:	d009      	beq.n	24a <Reset_Handler+0x1e>
 236:	4b22      	ldr	r3, [pc, #136]	; (2c0 <Reset_Handler+0x94>)
 238:	4a20      	ldr	r2, [pc, #128]	; (2bc <Reset_Handler+0x90>)
 23a:	e003      	b.n	244 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
 23c:	6811      	ldr	r1, [r2, #0]
 23e:	6019      	str	r1, [r3, #0]
 240:	3304      	adds	r3, #4
 242:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
 244:	491f      	ldr	r1, [pc, #124]	; (2c4 <Reset_Handler+0x98>)
 246:	428b      	cmp	r3, r1
 248:	d3f8      	bcc.n	23c <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
 24a:	4b1f      	ldr	r3, [pc, #124]	; (2c8 <Reset_Handler+0x9c>)
 24c:	e002      	b.n	254 <Reset_Handler+0x28>
                *pDest++ = 0;
 24e:	2200      	movs	r2, #0
 250:	601a      	str	r2, [r3, #0]
 252:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
 254:	4a1d      	ldr	r2, [pc, #116]	; (2cc <Reset_Handler+0xa0>)
 256:	4293      	cmp	r3, r2
 258:	d3f9      	bcc.n	24e <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 25a:	4a1d      	ldr	r2, [pc, #116]	; (2d0 <Reset_Handler+0xa4>)
 25c:	21ff      	movs	r1, #255	; 0xff
 25e:	4b1d      	ldr	r3, [pc, #116]	; (2d4 <Reset_Handler+0xa8>)
 260:	438b      	bics	r3, r1
 262:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
 264:	39fd      	subs	r1, #253	; 0xfd
 266:	2390      	movs	r3, #144	; 0x90
 268:	005b      	lsls	r3, r3, #1
 26a:	4a1b      	ldr	r2, [pc, #108]	; (2d8 <Reset_Handler+0xac>)
 26c:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
 26e:	4a1b      	ldr	r2, [pc, #108]	; (2dc <Reset_Handler+0xb0>)
 270:	78d3      	ldrb	r3, [r2, #3]
 272:	2503      	movs	r5, #3
 274:	43ab      	bics	r3, r5
 276:	2402      	movs	r4, #2
 278:	4323      	orrs	r3, r4
 27a:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
 27c:	78d3      	ldrb	r3, [r2, #3]
 27e:	270c      	movs	r7, #12
 280:	43bb      	bics	r3, r7
 282:	2608      	movs	r6, #8
 284:	4333      	orrs	r3, r6
 286:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
 288:	4b15      	ldr	r3, [pc, #84]	; (2e0 <Reset_Handler+0xb4>)
 28a:	7b98      	ldrb	r0, [r3, #14]
 28c:	2230      	movs	r2, #48	; 0x30
 28e:	4390      	bics	r0, r2
 290:	2220      	movs	r2, #32
 292:	4310      	orrs	r0, r2
 294:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
 296:	7b99      	ldrb	r1, [r3, #14]
 298:	43b9      	bics	r1, r7
 29a:	4331      	orrs	r1, r6
 29c:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
 29e:	7b9a      	ldrb	r2, [r3, #14]
 2a0:	43aa      	bics	r2, r5
 2a2:	4322      	orrs	r2, r4
 2a4:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
 2a6:	4a0f      	ldr	r2, [pc, #60]	; (2e4 <Reset_Handler+0xb8>)
 2a8:	6851      	ldr	r1, [r2, #4]
 2aa:	2380      	movs	r3, #128	; 0x80
 2ac:	430b      	orrs	r3, r1
 2ae:	6053      	str	r3, [r2, #4]
        __libc_init_array();
 2b0:	4b0d      	ldr	r3, [pc, #52]	; (2e8 <Reset_Handler+0xbc>)
 2b2:	4798      	blx	r3
        main();
 2b4:	4b0d      	ldr	r3, [pc, #52]	; (2ec <Reset_Handler+0xc0>)
 2b6:	4798      	blx	r3
 2b8:	e7fe      	b.n	2b8 <Reset_Handler+0x8c>
 2ba:	46c0      	nop			; (mov r8, r8)
 2bc:	000007c8 	.word	0x000007c8
 2c0:	20000000 	.word	0x20000000
 2c4:	20000434 	.word	0x20000434
 2c8:	20000434 	.word	0x20000434
 2cc:	20000684 	.word	0x20000684
 2d0:	e000ed00 	.word	0xe000ed00
 2d4:	00000000 	.word	0x00000000
 2d8:	41007000 	.word	0x41007000
 2dc:	41005000 	.word	0x41005000
 2e0:	41004800 	.word	0x41004800
 2e4:	41004000 	.word	0x41004000
 2e8:	000005dd 	.word	0x000005dd
 2ec:	00000551 	.word	0x00000551

000002f0 <long_division>:
/*
* internal Calculate 64 bit division, ref can be found in
* http://en.wikipedia.org/wiki/Division_algorithm#Long_division
*/
static uint64_t long_division(uint64_t n, uint64_t d)
{
 2f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 2f2:	46de      	mov	lr, fp
 2f4:	4657      	mov	r7, sl
 2f6:	464e      	mov	r6, r9
 2f8:	4645      	mov	r5, r8
 2fa:	b5e0      	push	{r5, r6, r7, lr}
 2fc:	b085      	sub	sp, #20
 2fe:	4689      	mov	r9, r1
 300:	0016      	movs	r6, r2
 302:	001f      	movs	r7, r3
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
 304:	2200      	movs	r2, #0
 306:	2300      	movs	r3, #0
 308:	2100      	movs	r1, #0
 30a:	468b      	mov	fp, r1
 30c:	468a      	mov	sl, r1
	for (i = 63; i >= 0; i--)
 30e:	253f      	movs	r5, #63	; 0x3f
 310:	9600      	str	r6, [sp, #0]
 312:	9701      	str	r7, [sp, #4]
 314:	9002      	str	r0, [sp, #8]
 316:	4649      	mov	r1, r9
 318:	9103      	str	r1, [sp, #12]
 31a:	e011      	b.n	340 <long_division+0x50>
	{
		bit_shift = (uint64_t)1 << i;
 31c:	2120      	movs	r1, #32
 31e:	1b49      	subs	r1, r1, r5
 320:	2400      	movs	r4, #0
 322:	3401      	adds	r4, #1
 324:	40cc      	lsrs	r4, r1
 326:	e013      	b.n	350 <long_division+0x60>
		r = r << 1;
		if (n & bit_shift) r |= 0x01;
		if (r >= d)
		{
			r = r - d;
 328:	9800      	ldr	r0, [sp, #0]
 32a:	9901      	ldr	r1, [sp, #4]
 32c:	1a12      	subs	r2, r2, r0
 32e:	418b      	sbcs	r3, r1
			q |= bit_shift;
 330:	4659      	mov	r1, fp
 332:	4660      	mov	r0, ip
 334:	4301      	orrs	r1, r0
 336:	468b      	mov	fp, r1
 338:	4651      	mov	r1, sl
 33a:	4321      	orrs	r1, r4
 33c:	468a      	mov	sl, r1
	for (i = 63; i >= 0; i--)
 33e:	3d01      	subs	r5, #1
 340:	2d00      	cmp	r5, #0
 342:	db23      	blt.n	38c <long_division+0x9c>
		bit_shift = (uint64_t)1 << i;
 344:	2120      	movs	r1, #32
 346:	4249      	negs	r1, r1
 348:	1869      	adds	r1, r5, r1
 34a:	d4e7      	bmi.n	31c <long_division+0x2c>
 34c:	2401      	movs	r4, #1
 34e:	408c      	lsls	r4, r1
 350:	2101      	movs	r1, #1
 352:	40a9      	lsls	r1, r5
 354:	468c      	mov	ip, r1
		r = r << 1;
 356:	1892      	adds	r2, r2, r2
 358:	415b      	adcs	r3, r3
 35a:	0010      	movs	r0, r2
 35c:	0019      	movs	r1, r3
		if (n & bit_shift) r |= 0x01;
 35e:	9e02      	ldr	r6, [sp, #8]
 360:	4667      	mov	r7, ip
 362:	403e      	ands	r6, r7
 364:	46b1      	mov	r9, r6
 366:	9e03      	ldr	r6, [sp, #12]
 368:	4026      	ands	r6, r4
 36a:	46b0      	mov	r8, r6
 36c:	464e      	mov	r6, r9
 36e:	4647      	mov	r7, r8
 370:	433e      	orrs	r6, r7
 372:	d003      	beq.n	37c <long_division+0x8c>
 374:	2601      	movs	r6, #1
 376:	4306      	orrs	r6, r0
 378:	0032      	movs	r2, r6
 37a:	000b      	movs	r3, r1
		if (r >= d)
 37c:	9800      	ldr	r0, [sp, #0]
 37e:	9901      	ldr	r1, [sp, #4]
 380:	4299      	cmp	r1, r3
 382:	d8dc      	bhi.n	33e <long_division+0x4e>
 384:	d1d0      	bne.n	328 <long_division+0x38>
 386:	4290      	cmp	r0, r2
 388:	d8d9      	bhi.n	33e <long_division+0x4e>
 38a:	e7cd      	b.n	328 <long_division+0x38>
		}
	}
	return q;
}
 38c:	4658      	mov	r0, fp
 38e:	4651      	mov	r1, sl
 390:	b005      	add	sp, #20
 392:	bc3c      	pop	{r2, r3, r4, r5}
 394:	4690      	mov	r8, r2
 396:	4699      	mov	r9, r3
 398:	46a2      	mov	sl, r4
 39a:	46ab      	mov	fp, r5
 39c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000003a0 <SERCOM3_Handler>:
	if(SERCOM3->USART.INTFLAG.bit.DRE)		//Wyst¹pi³o przerwniae DRE - mamy miejsce w buforze nadajnika
 3a0:	4b19      	ldr	r3, [pc, #100]	; (408 <SERCOM3_Handler+0x68>)
 3a2:	7e1b      	ldrb	r3, [r3, #24]
 3a4:	07db      	lsls	r3, r3, #31
 3a6:	d41e      	bmi.n	3e6 <SERCOM3_Handler+0x46>
	if(SERCOM3->USART.INTFLAG.bit.RXC)		//Odebralimy nowy znak
 3a8:	4b17      	ldr	r3, [pc, #92]	; (408 <SERCOM3_Handler+0x68>)
 3aa:	7e1b      	ldrb	r3, [r3, #24]
 3ac:	075b      	lsls	r3, r3, #29
 3ae:	d50c      	bpl.n	3ca <SERCOM3_Handler+0x2a>
		RxBuffer[RxBufferWriteIndex] =SERCOM3->USART.DATA.reg;		//Zapisz odczytany znak do bufora
 3b0:	4a16      	ldr	r2, [pc, #88]	; (40c <SERCOM3_Handler+0x6c>)
 3b2:	7813      	ldrb	r3, [r2, #0]
 3b4:	4914      	ldr	r1, [pc, #80]	; (408 <SERCOM3_Handler+0x68>)
 3b6:	8d08      	ldrh	r0, [r1, #40]	; 0x28
 3b8:	4915      	ldr	r1, [pc, #84]	; (410 <SERCOM3_Handler+0x70>)
 3ba:	54c8      	strb	r0, [r1, r3]
		RxBufferWriteIndex = (RxBufferWriteIndex + 1) % sizeof(RxBuffer);
 3bc:	3301      	adds	r3, #1
 3be:	7013      	strb	r3, [r2, #0]
		RxBufferCnt++;		
 3c0:	4a14      	ldr	r2, [pc, #80]	; (414 <SERCOM3_Handler+0x74>)
 3c2:	7813      	ldrb	r3, [r2, #0]
 3c4:	3301      	adds	r3, #1
 3c6:	b2db      	uxtb	r3, r3
 3c8:	7013      	strb	r3, [r2, #0]
}
 3ca:	4770      	bx	lr
			SERCOM3->USART.DATA.reg = TxBuffer[TxBufferReadIndex++];
 3cc:	4a12      	ldr	r2, [pc, #72]	; (418 <SERCOM3_Handler+0x78>)
 3ce:	7813      	ldrb	r3, [r2, #0]
 3d0:	1c59      	adds	r1, r3, #1
 3d2:	7011      	strb	r1, [r2, #0]
 3d4:	4a11      	ldr	r2, [pc, #68]	; (41c <SERCOM3_Handler+0x7c>)
 3d6:	5cd2      	ldrb	r2, [r2, r3]
 3d8:	4b0b      	ldr	r3, [pc, #44]	; (408 <SERCOM3_Handler+0x68>)
 3da:	851a      	strh	r2, [r3, #40]	; 0x28
			TxBufferCnt--;
 3dc:	4a10      	ldr	r2, [pc, #64]	; (420 <SERCOM3_Handler+0x80>)
 3de:	7813      	ldrb	r3, [r2, #0]
 3e0:	3b01      	subs	r3, #1
 3e2:	b2db      	uxtb	r3, r3
 3e4:	7013      	strb	r3, [r2, #0]
		while((TxBufferCnt) && (SERCOM3->USART.INTFLAG.bit.DRE))	//Zapisujemy a¿ skoñczy siê miejsce w buforze
 3e6:	4b0e      	ldr	r3, [pc, #56]	; (420 <SERCOM3_Handler+0x80>)
 3e8:	781b      	ldrb	r3, [r3, #0]
 3ea:	2b00      	cmp	r3, #0
 3ec:	d003      	beq.n	3f6 <SERCOM3_Handler+0x56>
 3ee:	4b06      	ldr	r3, [pc, #24]	; (408 <SERCOM3_Handler+0x68>)
 3f0:	7e1b      	ldrb	r3, [r3, #24]
 3f2:	07db      	lsls	r3, r3, #31
 3f4:	d4ea      	bmi.n	3cc <SERCOM3_Handler+0x2c>
		if(TxBufferCnt == 0) SERCOM3->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;	//nie ma nic do nadania, wiêc blokujemy przerwanie
 3f6:	4b0a      	ldr	r3, [pc, #40]	; (420 <SERCOM3_Handler+0x80>)
 3f8:	781b      	ldrb	r3, [r3, #0]
 3fa:	2b00      	cmp	r3, #0
 3fc:	d1d4      	bne.n	3a8 <SERCOM3_Handler+0x8>
 3fe:	2201      	movs	r2, #1
 400:	4b01      	ldr	r3, [pc, #4]	; (408 <SERCOM3_Handler+0x68>)
 402:	751a      	strb	r2, [r3, #20]
 404:	e7d0      	b.n	3a8 <SERCOM3_Handler+0x8>
 406:	46c0      	nop			; (mov r8, r8)
 408:	42001400 	.word	0x42001400
 40c:	20000459 	.word	0x20000459
 410:	2000045c 	.word	0x2000045c
 414:	20000458 	.word	0x20000458
 418:	20000457 	.word	0x20000457
 41c:	2000055c 	.word	0x2000055c
 420:	20000456 	.word	0x20000456

00000424 <calculate_baud_value>:

/*
* \internal Calculate asynchronous baudrate value (UART)
*/
uint16_t calculate_baud_value(const uint32_t baudrate, const uint32_t peripheral_clock, uint8_t sample_num)
{
 424:	b570      	push	{r4, r5, r6, lr}
 426:	000c      	movs	r4, r1
 428:	0011      	movs	r1, r2
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
	uint64_t temp1;
	/* Calculate the BAUD value */
	temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
 42a:	0002      	movs	r2, r0
 42c:	2300      	movs	r3, #0
 42e:	0008      	movs	r0, r1
 430:	2100      	movs	r1, #0
 432:	4d08      	ldr	r5, [pc, #32]	; (454 <calculate_baud_value+0x30>)
 434:	47a8      	blx	r5
 436:	0001      	movs	r1, r0
	ratio = long_division(temp1, peripheral_clock);
 438:	0022      	movs	r2, r4
 43a:	2300      	movs	r3, #0
 43c:	2000      	movs	r0, #0
 43e:	4c06      	ldr	r4, [pc, #24]	; (458 <calculate_baud_value+0x34>)
 440:	47a0      	blx	r4
	scale = ((uint64_t)1 << SHIFT) - ratio;
 442:	2200      	movs	r2, #0
 444:	2301      	movs	r3, #1
 446:	1a12      	subs	r2, r2, r0
 448:	418b      	sbcs	r3, r1
	baud_calculated = (65536 * scale) >> SHIFT;
 44a:	0c12      	lsrs	r2, r2, #16
 44c:	0418      	lsls	r0, r3, #16
 44e:	4310      	orrs	r0, r2
	return baud_calculated;
 450:	b280      	uxth	r0, r0
}
 452:	bd70      	pop	{r4, r5, r6, pc}
 454:	00000589 	.word	0x00000589
 458:	000002f1 	.word	0x000002f1

0000045c <UART_init>:
{
 45c:	b510      	push	{r4, lr}
	REG_PM_APBCMASK |= PM_APBCMASK_SERCOM3;  //W³¹cz zegar dla SERCOM3
 45e:	4a1c      	ldr	r2, [pc, #112]	; (4d0 <UART_init+0x74>)
 460:	6813      	ldr	r3, [r2, #0]
 462:	2120      	movs	r1, #32
 464:	430b      	orrs	r3, r1
 466:	6013      	str	r3, [r2, #0]
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(GCLK_CLKCTRL_ID_SERCOM3_CORE_Val) | //Generic Clock 0
 468:	4a1a      	ldr	r2, [pc, #104]	; (4d4 <UART_init+0x78>)
 46a:	4b1b      	ldr	r3, [pc, #108]	; (4d8 <UART_init+0x7c>)
 46c:	805a      	strh	r2, [r3, #2]
	while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY); //Zaczekaj na synchronizacjê
 46e:	4b1a      	ldr	r3, [pc, #104]	; (4d8 <UART_init+0x7c>)
 470:	785b      	ldrb	r3, [r3, #1]
 472:	b25b      	sxtb	r3, r3
 474:	2b00      	cmp	r3, #0
 476:	dbfa      	blt.n	46e <UART_init+0x12>
	SERCOM3->USART.CTRLA.reg = SERCOM_USART_CTRLA_DORD | SERCOM_USART_CTRLA_FORM(0) | SERCOM_USART_CTRLA_RXPO(1)
 478:	4c18      	ldr	r4, [pc, #96]	; (4dc <UART_init+0x80>)
 47a:	4b19      	ldr	r3, [pc, #100]	; (4e0 <UART_init+0x84>)
 47c:	6023      	str	r3, [r4, #0]
	SERCOM3->USART.BAUD.reg = calculate_baud_value(9600, 48000000, 16);
 47e:	2210      	movs	r2, #16
 480:	4918      	ldr	r1, [pc, #96]	; (4e4 <UART_init+0x88>)
 482:	2096      	movs	r0, #150	; 0x96
 484:	0180      	lsls	r0, r0, #6
 486:	4b18      	ldr	r3, [pc, #96]	; (4e8 <UART_init+0x8c>)
 488:	4798      	blx	r3
 48a:	81a0      	strh	r0, [r4, #12]
	SERCOM3->USART.CTRLB.reg = SERCOM_USART_CTRLB_CHSIZE(0x0) | SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN;
 48c:	23c0      	movs	r3, #192	; 0xc0
 48e:	029b      	lsls	r3, r3, #10
 490:	6063      	str	r3, [r4, #4]
	while(SERCOM3->USART.SYNCBUSY.bit.CTRLB);		//Zaczekaj na synchronizacjê rejestrów
 492:	4b12      	ldr	r3, [pc, #72]	; (4dc <UART_init+0x80>)
 494:	69db      	ldr	r3, [r3, #28]
 496:	075b      	lsls	r3, r3, #29
 498:	d4fb      	bmi.n	492 <UART_init+0x36>
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
 49a:	4a14      	ldr	r2, [pc, #80]	; (4ec <UART_init+0x90>)
 49c:	21c3      	movs	r1, #195	; 0xc3
 49e:	0089      	lsls	r1, r1, #2
 4a0:	5853      	ldr	r3, [r2, r1]
 4a2:	20ff      	movs	r0, #255	; 0xff
 4a4:	4383      	bics	r3, r0
 4a6:	383f      	subs	r0, #63	; 0x3f
 4a8:	4303      	orrs	r3, r0
 4aa:	5053      	str	r3, [r2, r1]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 4ac:	2380      	movs	r3, #128	; 0x80
 4ae:	015b      	lsls	r3, r3, #5
 4b0:	6013      	str	r3, [r2, #0]
	SERCOM3->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
 4b2:	4b0a      	ldr	r3, [pc, #40]	; (4dc <UART_init+0x80>)
 4b4:	2204      	movs	r2, #4
 4b6:	759a      	strb	r2, [r3, #22]
	SERCOM3->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;				//Odblokuj UART
 4b8:	681a      	ldr	r2, [r3, #0]
 4ba:	2102      	movs	r1, #2
 4bc:	430a      	orrs	r2, r1
 4be:	601a      	str	r2, [r3, #0]
	while(SERCOM3->USART.SYNCBUSY.reg & SERCOM_USART_SYNCBUSY_ENABLE);	//Zaczekaj na koniec operacji
 4c0:	4b06      	ldr	r3, [pc, #24]	; (4dc <UART_init+0x80>)
 4c2:	69db      	ldr	r3, [r3, #28]
 4c4:	079b      	lsls	r3, r3, #30
 4c6:	d4fb      	bmi.n	4c0 <UART_init+0x64>
	PORT->Group[0].WRCONFIG.reg = PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_PMUX(2) | PORT_WRCONFIG_PMUXEN | 0b11000000; //Wybierz funkcjê SERCOM1 dla PA22-23
 4c8:	4a09      	ldr	r2, [pc, #36]	; (4f0 <UART_init+0x94>)
 4ca:	4b0a      	ldr	r3, [pc, #40]	; (4f4 <UART_init+0x98>)
 4cc:	629a      	str	r2, [r3, #40]	; 0x28
}
 4ce:	bd10      	pop	{r4, pc}
 4d0:	40000420 	.word	0x40000420
 4d4:	00004017 	.word	0x00004017
 4d8:	40000c00 	.word	0x40000c00
 4dc:	42001400 	.word	0x42001400
 4e0:	40100004 	.word	0x40100004
 4e4:	02dc6c00 	.word	0x02dc6c00
 4e8:	00000425 	.word	0x00000425
 4ec:	e000e100 	.word	0xe000e100
 4f0:	d20100c0 	.word	0xd20100c0
 4f4:	41004400 	.word	0x41004400

000004f8 <USART_SendCh>:

void USART_SendCh(uint8_t ch)
{
//	while(!(SERCOM3->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));  //Zaczekaj na wys³anie danych
//	SERCOM3->USART.DATA.reg=ch;
	TxBuffer[TxBufferWriteIndex++] = ch;
 4f8:	4a08      	ldr	r2, [pc, #32]	; (51c <USART_SendCh+0x24>)
 4fa:	7813      	ldrb	r3, [r2, #0]
 4fc:	1c59      	adds	r1, r3, #1
 4fe:	7011      	strb	r1, [r2, #0]
 500:	4a07      	ldr	r2, [pc, #28]	; (520 <USART_SendCh+0x28>)
 502:	54d0      	strb	r0, [r2, r3]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 504:	b672      	cpsid	i
	TxBufferWriteIndex%=sizeof(TxBuffer);
	__disable_irq();
	 TxBufferCnt++;		//Sekcja krytyczna
 506:	4a07      	ldr	r2, [pc, #28]	; (524 <USART_SendCh+0x2c>)
 508:	7813      	ldrb	r3, [r2, #0]
 50a:	3301      	adds	r3, #1
 50c:	b2db      	uxtb	r3, r3
 50e:	7013      	strb	r3, [r2, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 510:	b662      	cpsie	i
	 __enable_irq();
	SERCOM3->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;			//Odblokuj przerwanie DRE
 512:	2201      	movs	r2, #1
 514:	4b04      	ldr	r3, [pc, #16]	; (528 <USART_SendCh+0x30>)
 516:	759a      	strb	r2, [r3, #22]
}
 518:	4770      	bx	lr
 51a:	46c0      	nop			; (mov r8, r8)
 51c:	20000455 	.word	0x20000455
 520:	2000055c 	.word	0x2000055c
 524:	20000456 	.word	0x20000456
 528:	42001400 	.word	0x42001400

0000052c <USART_SendText>:

void USART_SendText(char *text)
{
 52c:	b510      	push	{r4, lr}
 52e:	0004      	movs	r4, r0
 530:	e004      	b.n	53c <USART_SendText+0x10>
	do{
		if(*text) USART_SendCh(*text);			//Wylij znak
	} while(*text++ != 0);			//Pêtla a¿ do napotkania znaku NUL
 532:	1c62      	adds	r2, r4, #1
 534:	7823      	ldrb	r3, [r4, #0]
 536:	2b00      	cmp	r3, #0
 538:	d006      	beq.n	548 <USART_SendText+0x1c>
 53a:	0014      	movs	r4, r2
		if(*text) USART_SendCh(*text);			//Wylij znak
 53c:	7820      	ldrb	r0, [r4, #0]
 53e:	2800      	cmp	r0, #0
 540:	d0f7      	beq.n	532 <USART_SendText+0x6>
 542:	4b02      	ldr	r3, [pc, #8]	; (54c <USART_SendText+0x20>)
 544:	4798      	blx	r3
 546:	e7f4      	b.n	532 <USART_SendText+0x6>
}
 548:	bd10      	pop	{r4, pc}
 54a:	46c0      	nop			; (mov r8, r8)
 54c:	000004f9 	.word	0x000004f9

00000550 <main>:

int main(void)
{
 550:	b510      	push	{r4, lr}
	Set48MHzClk();
 552:	4b08      	ldr	r3, [pc, #32]	; (574 <main+0x24>)
 554:	4798      	blx	r3
	UART_init();
 556:	4b08      	ldr	r3, [pc, #32]	; (578 <main+0x28>)
 558:	4798      	blx	r3
 55a:	b662      	cpsie	i
	__enable_irq();			//Zezwól globalnie na przerwania

	while(1)
	{
		USART_SendText("Hi, this is ARM & interrupts...\r\n");
 55c:	4807      	ldr	r0, [pc, #28]	; (57c <main+0x2c>)
 55e:	4b08      	ldr	r3, [pc, #32]	; (580 <main+0x30>)
 560:	4798      	blx	r3

extern __IO uint32_t TimingDelay;

static inline void _delay_ms(__IO uint32_t nTime)
{
	TimingDelay = nTime;
 562:	4b08      	ldr	r3, [pc, #32]	; (584 <main+0x34>)
 564:	22fa      	movs	r2, #250	; 0xfa
 566:	0052      	lsls	r2, r2, #1
 568:	601a      	str	r2, [r3, #0]
	
	while(TimingDelay != 0);
 56a:	4b06      	ldr	r3, [pc, #24]	; (584 <main+0x34>)
 56c:	681b      	ldr	r3, [r3, #0]
 56e:	2b00      	cmp	r3, #0
 570:	d1fb      	bne.n	56a <main+0x1a>
 572:	e7f3      	b.n	55c <main+0xc>
 574:	000001a9 	.word	0x000001a9
 578:	0000045d 	.word	0x0000045d
 57c:	0000077c 	.word	0x0000077c
 580:	0000052d 	.word	0x0000052d
 584:	20000450 	.word	0x20000450

00000588 <__aeabi_lmul>:
 588:	b5f0      	push	{r4, r5, r6, r7, lr}
 58a:	46ce      	mov	lr, r9
 58c:	4647      	mov	r7, r8
 58e:	0415      	lsls	r5, r2, #16
 590:	0c2d      	lsrs	r5, r5, #16
 592:	002e      	movs	r6, r5
 594:	b580      	push	{r7, lr}
 596:	0407      	lsls	r7, r0, #16
 598:	0c14      	lsrs	r4, r2, #16
 59a:	0c3f      	lsrs	r7, r7, #16
 59c:	4699      	mov	r9, r3
 59e:	0c03      	lsrs	r3, r0, #16
 5a0:	437e      	muls	r6, r7
 5a2:	435d      	muls	r5, r3
 5a4:	4367      	muls	r7, r4
 5a6:	4363      	muls	r3, r4
 5a8:	197f      	adds	r7, r7, r5
 5aa:	0c34      	lsrs	r4, r6, #16
 5ac:	19e4      	adds	r4, r4, r7
 5ae:	469c      	mov	ip, r3
 5b0:	42a5      	cmp	r5, r4
 5b2:	d903      	bls.n	5bc <__aeabi_lmul+0x34>
 5b4:	2380      	movs	r3, #128	; 0x80
 5b6:	025b      	lsls	r3, r3, #9
 5b8:	4698      	mov	r8, r3
 5ba:	44c4      	add	ip, r8
 5bc:	464b      	mov	r3, r9
 5be:	4351      	muls	r1, r2
 5c0:	4343      	muls	r3, r0
 5c2:	0436      	lsls	r6, r6, #16
 5c4:	0c36      	lsrs	r6, r6, #16
 5c6:	0c25      	lsrs	r5, r4, #16
 5c8:	0424      	lsls	r4, r4, #16
 5ca:	4465      	add	r5, ip
 5cc:	19a4      	adds	r4, r4, r6
 5ce:	1859      	adds	r1, r3, r1
 5d0:	1949      	adds	r1, r1, r5
 5d2:	0020      	movs	r0, r4
 5d4:	bc0c      	pop	{r2, r3}
 5d6:	4690      	mov	r8, r2
 5d8:	4699      	mov	r9, r3
 5da:	bdf0      	pop	{r4, r5, r6, r7, pc}

000005dc <__libc_init_array>:
 5dc:	b570      	push	{r4, r5, r6, lr}
 5de:	4e0d      	ldr	r6, [pc, #52]	; (614 <__libc_init_array+0x38>)
 5e0:	4d0d      	ldr	r5, [pc, #52]	; (618 <__libc_init_array+0x3c>)
 5e2:	2400      	movs	r4, #0
 5e4:	1bad      	subs	r5, r5, r6
 5e6:	10ad      	asrs	r5, r5, #2
 5e8:	d005      	beq.n	5f6 <__libc_init_array+0x1a>
 5ea:	00a3      	lsls	r3, r4, #2
 5ec:	58f3      	ldr	r3, [r6, r3]
 5ee:	3401      	adds	r4, #1
 5f0:	4798      	blx	r3
 5f2:	42a5      	cmp	r5, r4
 5f4:	d1f9      	bne.n	5ea <__libc_init_array+0xe>
 5f6:	f000 f8d5 	bl	7a4 <_init>
 5fa:	4e08      	ldr	r6, [pc, #32]	; (61c <__libc_init_array+0x40>)
 5fc:	4d08      	ldr	r5, [pc, #32]	; (620 <__libc_init_array+0x44>)
 5fe:	2400      	movs	r4, #0
 600:	1bad      	subs	r5, r5, r6
 602:	10ad      	asrs	r5, r5, #2
 604:	d005      	beq.n	612 <__libc_init_array+0x36>
 606:	00a3      	lsls	r3, r4, #2
 608:	58f3      	ldr	r3, [r6, r3]
 60a:	3401      	adds	r4, #1
 60c:	4798      	blx	r3
 60e:	42a5      	cmp	r5, r4
 610:	d1f9      	bne.n	606 <__libc_init_array+0x2a>
 612:	bd70      	pop	{r4, r5, r6, pc}
 614:	000007b0 	.word	0x000007b0
 618:	000007b0 	.word	0x000007b0
 61c:	000007b0 	.word	0x000007b0
 620:	000007b8 	.word	0x000007b8

00000624 <register_fini>:
 624:	4b03      	ldr	r3, [pc, #12]	; (634 <register_fini+0x10>)
 626:	b510      	push	{r4, lr}
 628:	2b00      	cmp	r3, #0
 62a:	d002      	beq.n	632 <register_fini+0xe>
 62c:	4802      	ldr	r0, [pc, #8]	; (638 <register_fini+0x14>)
 62e:	f000 f805 	bl	63c <atexit>
 632:	bd10      	pop	{r4, pc}
 634:	00000000 	.word	0x00000000
 638:	0000064d 	.word	0x0000064d

0000063c <atexit>:
 63c:	b510      	push	{r4, lr}
 63e:	0001      	movs	r1, r0
 640:	2300      	movs	r3, #0
 642:	2200      	movs	r2, #0
 644:	2000      	movs	r0, #0
 646:	f000 f81f 	bl	688 <__register_exitproc>
 64a:	bd10      	pop	{r4, pc}

0000064c <__libc_fini_array>:
 64c:	b570      	push	{r4, r5, r6, lr}
 64e:	4b09      	ldr	r3, [pc, #36]	; (674 <__libc_fini_array+0x28>)
 650:	4c09      	ldr	r4, [pc, #36]	; (678 <__libc_fini_array+0x2c>)
 652:	1ae4      	subs	r4, r4, r3
 654:	10a4      	asrs	r4, r4, #2
 656:	d009      	beq.n	66c <__libc_fini_array+0x20>
 658:	4a08      	ldr	r2, [pc, #32]	; (67c <__libc_fini_array+0x30>)
 65a:	18a5      	adds	r5, r4, r2
 65c:	00ad      	lsls	r5, r5, #2
 65e:	18ed      	adds	r5, r5, r3
 660:	682b      	ldr	r3, [r5, #0]
 662:	3c01      	subs	r4, #1
 664:	4798      	blx	r3
 666:	3d04      	subs	r5, #4
 668:	2c00      	cmp	r4, #0
 66a:	d1f9      	bne.n	660 <__libc_fini_array+0x14>
 66c:	f000 f8a4 	bl	7b8 <_fini>
 670:	bd70      	pop	{r4, r5, r6, pc}
 672:	46c0      	nop			; (mov r8, r8)
 674:	000007c4 	.word	0x000007c4
 678:	000007c8 	.word	0x000007c8
 67c:	3fffffff 	.word	0x3fffffff

00000680 <__retarget_lock_acquire_recursive>:
 680:	4770      	bx	lr
 682:	46c0      	nop			; (mov r8, r8)

00000684 <__retarget_lock_release_recursive>:
 684:	4770      	bx	lr
 686:	46c0      	nop			; (mov r8, r8)

00000688 <__register_exitproc>:
 688:	b5f0      	push	{r4, r5, r6, r7, lr}
 68a:	464e      	mov	r6, r9
 68c:	4645      	mov	r5, r8
 68e:	46de      	mov	lr, fp
 690:	4657      	mov	r7, sl
 692:	b5e0      	push	{r5, r6, r7, lr}
 694:	4d36      	ldr	r5, [pc, #216]	; (770 <__register_exitproc+0xe8>)
 696:	b083      	sub	sp, #12
 698:	0006      	movs	r6, r0
 69a:	6828      	ldr	r0, [r5, #0]
 69c:	4698      	mov	r8, r3
 69e:	000f      	movs	r7, r1
 6a0:	4691      	mov	r9, r2
 6a2:	f7ff ffed 	bl	680 <__retarget_lock_acquire_recursive>
 6a6:	4b33      	ldr	r3, [pc, #204]	; (774 <__register_exitproc+0xec>)
 6a8:	681c      	ldr	r4, [r3, #0]
 6aa:	23a4      	movs	r3, #164	; 0xa4
 6ac:	005b      	lsls	r3, r3, #1
 6ae:	58e0      	ldr	r0, [r4, r3]
 6b0:	2800      	cmp	r0, #0
 6b2:	d052      	beq.n	75a <__register_exitproc+0xd2>
 6b4:	6843      	ldr	r3, [r0, #4]
 6b6:	2b1f      	cmp	r3, #31
 6b8:	dc13      	bgt.n	6e2 <__register_exitproc+0x5a>
 6ba:	1c5a      	adds	r2, r3, #1
 6bc:	9201      	str	r2, [sp, #4]
 6be:	2e00      	cmp	r6, #0
 6c0:	d128      	bne.n	714 <__register_exitproc+0x8c>
 6c2:	9a01      	ldr	r2, [sp, #4]
 6c4:	3302      	adds	r3, #2
 6c6:	009b      	lsls	r3, r3, #2
 6c8:	6042      	str	r2, [r0, #4]
 6ca:	501f      	str	r7, [r3, r0]
 6cc:	6828      	ldr	r0, [r5, #0]
 6ce:	f7ff ffd9 	bl	684 <__retarget_lock_release_recursive>
 6d2:	2000      	movs	r0, #0
 6d4:	b003      	add	sp, #12
 6d6:	bc3c      	pop	{r2, r3, r4, r5}
 6d8:	4690      	mov	r8, r2
 6da:	4699      	mov	r9, r3
 6dc:	46a2      	mov	sl, r4
 6de:	46ab      	mov	fp, r5
 6e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 6e2:	4b25      	ldr	r3, [pc, #148]	; (778 <__register_exitproc+0xf0>)
 6e4:	2b00      	cmp	r3, #0
 6e6:	d03d      	beq.n	764 <__register_exitproc+0xdc>
 6e8:	20c8      	movs	r0, #200	; 0xc8
 6ea:	0040      	lsls	r0, r0, #1
 6ec:	e000      	b.n	6f0 <__register_exitproc+0x68>
 6ee:	bf00      	nop
 6f0:	2800      	cmp	r0, #0
 6f2:	d037      	beq.n	764 <__register_exitproc+0xdc>
 6f4:	22a4      	movs	r2, #164	; 0xa4
 6f6:	2300      	movs	r3, #0
 6f8:	0052      	lsls	r2, r2, #1
 6fa:	58a1      	ldr	r1, [r4, r2]
 6fc:	6043      	str	r3, [r0, #4]
 6fe:	6001      	str	r1, [r0, #0]
 700:	50a0      	str	r0, [r4, r2]
 702:	3240      	adds	r2, #64	; 0x40
 704:	5083      	str	r3, [r0, r2]
 706:	3204      	adds	r2, #4
 708:	5083      	str	r3, [r0, r2]
 70a:	3301      	adds	r3, #1
 70c:	9301      	str	r3, [sp, #4]
 70e:	2300      	movs	r3, #0
 710:	2e00      	cmp	r6, #0
 712:	d0d6      	beq.n	6c2 <__register_exitproc+0x3a>
 714:	009a      	lsls	r2, r3, #2
 716:	4692      	mov	sl, r2
 718:	4482      	add	sl, r0
 71a:	464a      	mov	r2, r9
 71c:	2188      	movs	r1, #136	; 0x88
 71e:	4654      	mov	r4, sl
 720:	5062      	str	r2, [r4, r1]
 722:	22c4      	movs	r2, #196	; 0xc4
 724:	0052      	lsls	r2, r2, #1
 726:	4691      	mov	r9, r2
 728:	4481      	add	r9, r0
 72a:	464a      	mov	r2, r9
 72c:	3987      	subs	r1, #135	; 0x87
 72e:	4099      	lsls	r1, r3
 730:	6812      	ldr	r2, [r2, #0]
 732:	468b      	mov	fp, r1
 734:	430a      	orrs	r2, r1
 736:	4694      	mov	ip, r2
 738:	464a      	mov	r2, r9
 73a:	4661      	mov	r1, ip
 73c:	6011      	str	r1, [r2, #0]
 73e:	2284      	movs	r2, #132	; 0x84
 740:	4641      	mov	r1, r8
 742:	0052      	lsls	r2, r2, #1
 744:	50a1      	str	r1, [r4, r2]
 746:	2e02      	cmp	r6, #2
 748:	d1bb      	bne.n	6c2 <__register_exitproc+0x3a>
 74a:	0002      	movs	r2, r0
 74c:	465c      	mov	r4, fp
 74e:	328d      	adds	r2, #141	; 0x8d
 750:	32ff      	adds	r2, #255	; 0xff
 752:	6811      	ldr	r1, [r2, #0]
 754:	430c      	orrs	r4, r1
 756:	6014      	str	r4, [r2, #0]
 758:	e7b3      	b.n	6c2 <__register_exitproc+0x3a>
 75a:	0020      	movs	r0, r4
 75c:	304d      	adds	r0, #77	; 0x4d
 75e:	30ff      	adds	r0, #255	; 0xff
 760:	50e0      	str	r0, [r4, r3]
 762:	e7a7      	b.n	6b4 <__register_exitproc+0x2c>
 764:	6828      	ldr	r0, [r5, #0]
 766:	f7ff ff8d 	bl	684 <__retarget_lock_release_recursive>
 76a:	2001      	movs	r0, #1
 76c:	4240      	negs	r0, r0
 76e:	e7b1      	b.n	6d4 <__register_exitproc+0x4c>
 770:	20000430 	.word	0x20000430
 774:	000007a0 	.word	0x000007a0
 778:	00000000 	.word	0x00000000
 77c:	202c6948 	.word	0x202c6948
 780:	73696874 	.word	0x73696874
 784:	20736920 	.word	0x20736920
 788:	204d5241 	.word	0x204d5241
 78c:	6e692026 	.word	0x6e692026
 790:	72726574 	.word	0x72726574
 794:	73747075 	.word	0x73747075
 798:	0d2e2e2e 	.word	0x0d2e2e2e
 79c:	0000000a 	.word	0x0000000a

000007a0 <_global_impure_ptr>:
 7a0:	20000008                                ... 

000007a4 <_init>:
 7a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 7a6:	46c0      	nop			; (mov r8, r8)
 7a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 7aa:	bc08      	pop	{r3}
 7ac:	469e      	mov	lr, r3
 7ae:	4770      	bx	lr

000007b0 <__init_array_start>:
 7b0:	00000625 	.word	0x00000625

000007b4 <__frame_dummy_init_array_entry>:
 7b4:	000000dd                                ....

000007b8 <_fini>:
 7b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 7ba:	46c0      	nop			; (mov r8, r8)
 7bc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 7be:	bc08      	pop	{r3}
 7c0:	469e      	mov	lr, r3
 7c2:	4770      	bx	lr

000007c4 <__fini_array_start>:
 7c4:	000000b5 	.word	0x000000b5
